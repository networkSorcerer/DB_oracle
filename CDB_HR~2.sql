--PL/SQL은 문장에서 변수정의, 조건처리, 반복처리 등을 지원한다

--모든 문장의 종결기호는 세미콜론으로 명시해야 한다. 대입 연산자로는 :=을 사용한다
--대입 연산자는 변수의 선언시 및 변수의 대입에 이용된다
--SELECT문에 의해 추출되는 DATA는 INTO절의 변수에 저장해서 처리한다

BEGIN
DBMS_OUTPUT.PUT_LINE('HELLO WORLD');
END;

--변수
--IDENTIFIER 변수의 이름
--CONSTANT 변수의 값을 변경할수없도록 제약한다
--DATATYPE 자료형 (데이터 타입)을 기술한다
--변수데이터 타입 : SQL타입과 PL/SQL타입
--PL/SQL데이터 타입 : BOOLEAN, BINARY_INTEGER
--NOT NULL 값을 반드시 포함하도록 하기 위해 변수를 제약한다
--EXPRESSION LITERAL 다른변수 연산자나 함수를 포함하는 표현식

/
DECLARE
VAL_NUM NUMBER;
BEGIN
VAL_NUM := 100;
DBMS_OUTPUT.PUT_LINE(VAL_NUM);
END;
/

DECLARE
NUM NUMBER := 24*60*60;
BEGIN
DBMS_OUTPUT.PUT_LINE('NUM=' ||TO_CHAR(NUM));
END;
/

DECLARE
VEMPLOYEE_ID NUMBER(6);
VFIRST_NAME VARCHAR2(20);
BEGIN
VEMPLOYEE_ID :=105;
VFIRST_NAME := 'David';

DBMS_OUTPUT.PUT_LINE('사번 / 이름');
DBMS_OUTPUT.PUT_LINE('-----------');
DBMS_OUTPUT.PUT_LINE(VEMPLOYEE_ID || '/'||VFIRST_NAME);
END;
/

--스칼라 SQL에서의 자료형 지정과 거의 동일하다
--VEMPLOYEE_ID NUMBER(6);
--VFIRST_NAME VARCHAR2(20);

--레퍼런스 %TYPE속성과 %ROWTYPE속성 사용한다

--VEMPLOYEE_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
--VFIRST_NAME EMPLOYEES.FIRST_NAME%TYPE;
--VEMPLOYEES EMPLOYEES%ROWTYPE;
--PL/SQL에서 SQL문장
--SELECT_LIST 열의 목록이며 행 함수, 그룹함수, 표현식을 기술할수 있다
--VARIABLE_NAME 읽어들인 값을 저장하기 위한 스칼라 변수
--RECORD_NAME 읽어들인 값을 저장하기 위한 PL/SQL RECORD변수
--CONDITION PL/SQL변수와 상수를 포함하여 열명, 표현식, 상수, 비교연산자로 구성되며 오직 
--하나의 값을 RETURN할수 있는 조건이어야 한다

DECLARE
    --%TYPE 속성으로 칼럼 단위로 데이터를 저장할수있는 레퍼런스 변수 선언
    VEMPLOYEE_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
    VFIRST_NAME EMPLOYEES.FIRST_NAME%TYPE;
    BEGIN
    DBMS_OUTPUT.PUT_LINE('사번  /  이름');
    DBMS_OUTPUT.PUT_LINE('-------------');
    --SELECT 문을 수행한 결과값이 INTO뒤에 기술한 변수에 저장된다
    SELECT EMPLOYEE_ID, FIRST_NAME INTO VEMPLOYEE_ID, VFIRST_NAME
    FROM EMPLOYEES
    WHERE FIRST_NAME = 'Susan';
    DBMS_OUTPUT.PUT_LINE(VEMPLOYEE_ID||'/'||VFIRST_NAME);
    END;
    /


--전체레코드를 참조하기 위해서는 %ROWTYPE으로 선언하면 된다    
DECLARE
--레토드로 변수 선언
VEMPLOYEES EMPLOYEES%ROWTYPE;
BEGIN
--JONES 사원의 정보를 레코드 변수에 저장
SELECT*
INTO VEMPLOYEES
FROM EMPLOYEES
WHERE FIRST_NAME = 'Lisa';

--레코드 변수에 저장된 사원정보를 출력
DBMS_OUTPUT.PUT_LINE('사원번호 :' || TO_CHAR(VEMPLOYEES.EMPLOYEE_ID));
DBMS_OUTPUT.PUT_LINE('이름 :' || VEMPLOYEES.FIRST_NAME);
DBMS_OUTPUT.PUT_LINE('급여 :' || VEMPLOYEES.SALARY);
DBMS_OUTPUT.PUT_LINE('사원번호 :' || TO_CHAR(VEMPLOYEES.HIRE_DATE, 'YYYY-MM-DD'));
END;
/


--등록된 총사원의 수와 급여의 합, 급여의 평균을 변수에 대입하여 출력하여 보자
DECLARE
VCNT NUMBER;
VSUM NUMBER;
VAVG NUMBER(10,2);
BEGIN
SELECT COUNT(*), SUM(SALARY), AVG(SALARY) INTO VCNT, VSUM, VAVG
FROM EMPLOYEES;

DBMS_OUTPUT.PUT_LINE('총사원의수 : ' || VCNT);
DBMS_OUTPUT.PUT_LINE('급여의 합 : ' || VSUM);
DBMS_OUTPUT.PUT_LINE('급여의 평균 : ' || VAVG);
END;
/

--JACK  사원의 직무, 급여 , 입사일자, 부서명을 변수에 대입하여 출력하여 보자
DECLARE
VEMPLOYEES EMPLOYEES%ROWTYPE;
VDEPARTMENTS DEPARTMENTS%ROWTYPE;

BEGIN
SELECT JOB_ID, SALARY, HIRE_DATE, DEPARTMENT_NAME
INTO VEMPLOYEES.JOB_ID, VEMPLOYEES.SALARY, VEMPLOYEES.HIRE_DATE, VDEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES EMP INNER JOIN DEPARTMENTS DEPT
ON EMP.DEPARTMENT_ID = DEPT.DEPARTMENT_ID
WHERE  FIRST_NAME = 'Jack';

DBMS_OUTPUT.PUT_LINE('직무 : ' || VEMPLOYEES.JOB_ID);
DBMS_OUTPUT.PUT_LINE('급여 : ' || VEMPLOYEES.SALARY);
DBMS_OUTPUT.PUT_LINE('입사일자 : ' || VEMPLOYEES.HIRE_DATE);
DBMS_OUTPUT.PUT_LINE('부서명 : ' || VDEPARTMENTS.DEPARTMENT_NAME);
END;
/


DROP TABLE EMPLOYEES01;

CREATE TABLE EMPLOYEES01
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMPLOYEES01;
DESC EMPLOYEES01;

DECLARE
MAX_EMPLOYEE_ID EMPLOYEES01.EMPLOYEE_ID%TYPE;
BEGIN
SELECT MAX(EMPLOYEE_ID) INTO MAX_EMPLOYEE_ID FROM EMPLOYEES01;
INSERT INTO EMPLOYEE01 (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY, HIRE_DATE,
MANAGER_ID, JOB_ID, DEPARTMENT_ID)
VALUES (MAX_EMPLOYEE_ID + 3, 'Oliva','Gee','Spring', 2800,SYSDATE, 100 , 'PR_REP', 20);
COMMIT;
END;
/

SELECT * FROM EMPLOYEES01;