--급여를 입력받아 그 급여보다 많이 받는 사원의 사원번호, 이름, 급여을 외부로 전달하는 프로시저를 
--생성해 주세요

CREATE OR REPLACE PROCEDURE EMP_SAL_DATA
(VSALARY IN EMPLOYEES.SALARY%TYPE, VEMPLOYEES OUT SYS_REFCURSOR)
IS 
BEGIN
OPEN VEMPLOYEES FOR SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES WHERE SALARY > VSALARY;
END;
/
SHOW ERROR;

DECLARE
PEMPLOYEES SYS_REFCURSOR;
VEMPLOYEES EMPLOYEES%ROWTYPE;
BEGIN
EMP_SAL_DATA(12000, PEMPLOYEES);
LOOP
FETCH PEMPLOYEES INTO VEMPLOYEES.EMPLOYEE_ID, VEMPLOYEES.FIRST_NAME, VEMPLOYEES.SALARY;
EXIT WHEN PEMPLOYEES%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(VEMPLOYEES.EMPLOYEE_ID ||'.'||VEMPLOYEES.FIRST_NAME||''||
VEMPLOYEES.SALARY);
END LOOP;
END;
/
--각 부서에서 가장 급여를 많이 받는 사원의 사원번호, 이름, 부서번호, 급여, 입사일을 외부로 전달하는
--프로시저를 생성해 주세요(프로시저명 :  DEPT_SAL_DATA)

CREATE OR REPLACE PROCEDURE DEPT_SAL_DATA (v_results OUT SYS_REFCURSOR)
IS 
BEGIN
    OPEN v_results FOR
    SELECT e.employee_id,
           e.first_name,
           e.department_id,
           e.salary,
           e.hire_date
    FROM employees e
    JOIN (
        SELECT department_id, MAX(salary) AS max_salary
        FROM employees
        GROUP BY department_id
    ) max_sal ON e.department_id = max_sal.department_id 
              AND e.salary = max_sal.max_salary;
END;
/
DROP PROCEDURE DEPT_SAL_DATA;


CREATE OR REPLACE PROCEDURE DEPT_SAL_DATA 
IS
    CURSOR c_dept_sal_data IS
        SELECT e.employee_id,
               e.first_name,
               e.department_id,
               e.salary,
               e.hire_date
        FROM employees e
        JOIN (
            SELECT department_id, MAX(salary) AS max_salary
            FROM employees
            GROUP BY department_id
        ) max_sal ON e.department_id = max_sal.department_id 
                  AND e.salary = max_sal.max_salary;
    v_employee_id employees.employee_id%TYPE;
    v_first_name employees.first_name%TYPE;
    v_department_id employees.department_id%TYPE;
    v_salary employees.salary%TYPE;
    v_hire_date employees.hire_date%TYPE;
BEGIN
    OPEN c_dept_sal_data;
    LOOP
        FETCH c_dept_sal_data INTO v_employee_id, v_first_name, v_department_id, v_salary, v_hire_date;
        EXIT WHEN c_dept_sal_data%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_employee_id || ', First Name: ' || v_first_name || ', Department ID: ' || v_department_id || ', Salary: ' || v_salary || ', Hire Date: ' || v_hire_date);
    END LOOP;
    CLOSE c_dept_sal_data;
END;
/

--IN OUT MODE 매개변수
--매개변수를 통해 결과값을 입력 받아 다시 해당 매개변수값으로 변형된 DATA를 받는 형태이다
--IN과 OUT의 기능을 모두 수행한다 즉 실행환경에서 프로시저로 값을 전달하고 프로시저에서 실행환경으로
--변경된 값ㅇ를 전달할수있다

--2) 트리거 
--서브 프로그램 단위의 하나인 TRIGGER는 테이블 뷰, 스키마 또는 데이터 베이스에 관련된 
--PL/SQL 블록 (또는 프로시저)으로 관련된 특정 사건 (EVENT) 이 발생 될때마다 묵시적 (자동)으로 
--해당 PL/SQL블록이 실행된다 TRIGGER는 데이터 베이스 내에 오브젝트로서 저장되어 
--관리되고, TRIGGER 자체는 사용자가 지정해서 실행을 할수없으며, 오직 TRIGGER 생성시 정의한 
--특정 사건에 의해서만 묵시적인 자동실행이 이루어진다 TRIGGER를 이루는 TRIGGER몸체에 TCL명령
--즉, COMMIT, ROLLBACK, SAVEPONT 명령이 포함 될수없다

--트리거의 사전적인 의미는 방아쇠나 (방아쇠를) 쏘다 발사하다 (사건을) 유발시키다라는 의미가 있다
--PL/SQL에서의 트리거 역시 방아쇠가 당겨지면 자동으로 총알이 발사되듯이 어떠한 이벤트가 발생하면
--그에따라 다른 작업이 자동으로 처리 되는 것을 의미한다

--트리거란 특정 테이블의 데이터 변경이 가해졌을 때 자동으로 수행되는 저장 프로시저라고 할수있다
--앞서 배운 저장 프로시저는 필요할 때마다 사죵자가 직접 EXECTE명령어를 호출해야했다
--하지만 트리거는 이와 달리 테이블의 데이터가 INSERT, UPDATE, DELETE문에 의해 변경될때 자동으로 
--수행되므로 이 기능을 이용하며 여러가지 작업을 할수있다. 이런 이유로 트리거를 사용자가 직접 
--실행시킬수는 없다

SELECT EMPLOYEE_ID
, FIRST_NAME
, JOB_ID
, SALARY
, DEPARTMENT_ID
, ROW_NUMBER() OVER (PARTITION BY DEPARTMENT_ID ORDER BY EMPLOYEE_ID) AS RNUM
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID;

SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, HIRE_DATE
FROM (SELECT ROW_NUMBER() OVER(PARTITION BY DEPARTMENT_ID ORDER BY EMPLOYEE_ID) AS RNUM,
EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES) DATA
WHERE DATA.RNUM = 1;

SELECT E.FIRST_NAME, D.DEPARTMENT_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;


-- 사원 테이블에 로우가 추가되면 자동 수행할 트리거를 생성한다
DROP TABLE EMP03;

CREATE TABLE EMP03(
EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(20),
JOB VARCHAR2(50)
);

CREATE OR REPLACE TRIGGER EMP_TRG01
AFTER INSERT
ON EMP03
BEGIN
DBMS_OUTPUT.PUT_LINE('신입사원이 입사했습니다');
END;
/


INSERT INTO EMP03(EMPNO, ENAME, JOB)
VALUES(1, '홍길동','경영지원직(기획/전략)');


--사원 테이블에 새로운 데이터 즉 신입 사원이 들어오면 급여 테이블에 새로운 데이터를 
--자동으로 생성하고 싶을 경우, 사원 테이블에 트리거를 설정하여 구현할수 있다
CREATE TABLE SAL03(
SALNO NUMBER(4),
SAL NUMBER,
EMPNO NUMBER(4),
CONSTRAINT SAL03_PK PRIMARY KEY(SALNO),
CONSTRAINT SAL03_FK FOREIGN KEY(EMPNO) REFERENCES EMP03(EMPNO)
);

CREATE SEQUENCE SAL03_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100000
NOCYCLE
CACHE 2;

CREATE OR REPLACE TRIGGER EMP_TRG02
AFTER INSERT
ON EMP03
FOR EACH ROW
BEGIN
INSERT INTO SAL03(SALNO, SAL, EMPNO)
VALUES(SAL03_SEQ.NEXTVAL, 2000000, : NEW.EMPNO);
END;
/

DELETE FROM EMP03 WHERE EMPNO = 1;
INSERT INTO EMP03(EMPNO, ENAME, JOB)VALUES(1, '김철수', '경영지원직(구매/자재)');

SELECT * FROM EMP03;

SELECT * FROM SAL03;

INSERT INTO EMP03(EMPNO, ENAME, JOB)VALUES(2,'이영희','경영지원직(인사)');

CREATE OR REPLACE TRIGGER EMP_TRG03
AFTER DELETE ON EMP03
FOR EACH ROW
BEGIN
DELETE FROM SAL03 WHERE EMPNO =: OLD.EMPNO;
END;
/

DELETE FROM EMP03 WHERE EMPNO=2;

CREATE TABLE PRODUCT(
PCODE CHAR(6),
PNAME VARCHAR2(12) NOT NULL,
PCOMPANY VARCHAR2(12),
PPRICE NUMBER(8),
STOCK NUMBER DEFAULT 0,
CONSTRAINT PRODUCT_PK PRIMARY KEY(PCODE)
);

DROP TABLE PRODUCT;

CREATE TABLE RECEIVING(
RNO NUMBER(6),
PCODE CHAR(6),
RDATE DATE DEFAULT SYSDATE,
RQTY NUMBER(6),
RPRICE NUMBER(8),
RAMOUNT NUMBER(8),
CONSTRAINT RECEIVING_PK PRIMARY KEY(RNO),
CONSTRAINT RECEIVING_FK FOREIGN KEY(PCODE) REFERENCES PRODUCT(PCODE)
);

INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE)
VALUES('A00001','세탁기','LG',1500000);
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE)
VALUES('A00002','컴퓨터','LG',1000000);
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE)
VALUES('A00003','냉장고','삼성',4500000);

DROP TABLE RECEIVING;

CREATE OR REPLACE TRIGGER TRG_IN
AFTER INSERT ON RECEIVING
FOR EACH ROW
BEGIN
UPDATE PRODUCT
SET STOCK = STOCK + :NEW.RQTY 
WHERE PCODE = :NEW.PCODE;
END;
/

--트리거를 실행시킨 후 입고 테이블에 행을 추가한다. 입고 테이블에는 물론 상품 테이블의
--재고 수량이 변경됨을 확인할 수 있다
INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPRICE, RAMOUNT)
VALUES(1, 'A00001', 5,850000,950000);

SELECT * FROM RECEIVING;

SELECT * FROM PRODUCT;

--6. 입고 테이블에 상품이 입력되면 자동으로 상품 테이블의 재고 수량이 증가하게 된다. 
-- 입고 테이블에 또 다른 상품을 입력한다
INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPRICE, RAMOUNT)
VALUES(2, 'A00002', 10,680000,780000);

INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPRICE, RAMOUNT)
VALUES(3, 'A00003', 10,250000,300000);


--실습하기 갱신 트리거 작성하기 
--이미 입고된 상품에 대해서 입고 수량이 변경되면 상품 테이블의 재고수량 역시 변경되어야 한다
--이를 위한 갱신 트리거 작성해보자
--1. 갱신 트리거 생성

CREATE OR REPLACE TRIGGER TRG_UP
AFTER UPDATE ON RECEIVING
FOR EACH ROW
BEGIN
UPDATE PRODUCT
SET STOCK = STOCK + (-:OLD.RQTY+:NEW.RQTY)
WHERE PCODE =:NEW.PCODE;
END;
/

--입고 번호 3번은 냉장고가 입고된 정보를 기록한 것으로서 입고 번호 3번의 입고수량을 8로 변경하였더니
--냉장고의 재고 수량 역시 8로 변경되었다
UPDATE RECEIVING SET RQTY=8, RAMOUNT=280000--입고수량과 입고금액
WHERE RNO=3;

SELECT * FROM RECEIVING;

SELECT * FROM PRODUCT;

--실습하기 삭제 트리거 작성하기
--입고 테이블에서 입고 되었던 상황이 삭제되면 상품 테이블에 재고수량에서 삭제된 입고 수량만큼을 
--빼는 삭제 트리거 작성해 보자
--1. 삭제 트리거 생성

CREATE OR REPLACE TRIGGER TRG_DEL
AFTER DELETE ON RECEIVING
FOR EACH ROW
BEGIN
UPDATE PRODUCT
SET STOCK = STOCK-:OLD.RQTY
WHERE PCODE =:OLD.PCODE;
END;
/

DELETE RECEIVING WHERE RNO = 3;

SELECT * FROM RECEIVING;

SELECT * FROM PRODUCT;











--FUNCTION이란?
--값을 반환하는 명명된 PL/SQL BLOCK으로 오라를  내장함수와 같이 SQL표현식의 일부로 상용하여
--SQL문을 간단한 형태로 사용할수 있다. 값을 반환하는 RETURN이 반드시 포함되며 반드시 한의 값을 
--반환한다 그래서 내장 함수와 프로시저는문법이나 특징이 거의 비슷하지만 
--차이점은 프로시저는 정해진 작업을 수행한 후 결과를 반환 할수도 있고(OUT,IN OUT 모드 사용시)
--반환하지 않고 그냥 종료 할수도있지만 함수는 정해진 작업을 수행한후 결과를 돌려준다 (RETURN)
--하는 부분이다 이때 RETURN의 데이터 타입은 오직 CHAR, DATE, NUMBER여야 한다

--부서 번호를 매개 변수로 부서의 이름을 반환하는 함수를 생성하여 봅시다 (첫번째 방법)
CREATE OR REPLACE FUNCTION GETDNAME(VDEPARTMENT_ID IN DEPARTMENTS.DEPARTMENT_ID%TYPE)
RETURN VARCHAR2
IS
VDEPARTMENT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE;
VCOUNT NUMBER :=0;
BEGIN
SELECT COUNT(*) INTO VCOUNT FROM DEPARTMENTS
WHERE DEPARTMENT_ID=VDEPARTMENT_ID;

IF VCOUNT = 0 THEN
VDEPARTMENT_NAME :='해당부서없음';
ELSE
SELECT DEPARTMENT_NAME INTO VDEPARTMENT_NAME FROM DEPARTMENTS
WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
END IF;
RETURN VDEPARTMENT_NAME;
END;
/

SELECT FIRST_NAME , JOB_ID, NVL(COMMISSION_PCT,0) COMMISSION_PCT, SALARY,
GETDNAME(DEPARTMENT_ID)DNAME
FROM EMPLOYEES
WHERE FIRST_NAME='Lisa';

SELECT GETDNAME(500) FROM DUAL;

--부서 번호를 매개 변수로 부서의 이름을 반환하는 함수를 생성하여 봅시다

CREATE OR REPLACE FUNCTION GETDNAME(VDEPARTMENT_ID IN DEPARTMENTS.DEPARTMENT_ID%TYPE)
RETURN VARCHAR2
IS
VDEPARTMENT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE;
BEGIN
SELECT DEPARTMENT_NAME INTO VDEPARTMENT_NAME FROM DEPARTMENTS
WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
RETURN VDEPARTMENT_NAME;

EXCEPTION
WHEN NO_DATA_FOUND THEN
VDEPARTMENT_NAME :='해당 부서 없음';
RETURN VDEPARTMENT_NAME;
END;
/

SELECT EMPLOYEE_ID, FIRST_NAME, TO_CHAR(HIRE_DATE, 'YYYY-MM-DD')HIREDATE,
GETDNAME(DEPARTMENT_ID)DEPARTMENT_NAME
FROM EMPLOYEES;

SELECT GETDNAME(400) FROM DUAL;

CREATE OR REPLACE FUNCTION GETSUMDEPT(VDEPARTMENT_ID IN DEPARTMENTS.DEPARTMENT_ID%TYPE)
RETURN VARCHAR2
IS
VSUMSALARY VARCHAR2(50);
BEGIN
SELECT NVL(TO_CHAR (ROUND(SUM(SALARY)),'999999'), '해당 부서 없음') INTO VSUMSALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
RETURN VSUMSALARY;
END;
/

SELECT FIRST_NAME, SALARY, DEPARTMENT_ID , GETDNAME(DEPARTMENT_ID) DEPARTMENT_NAME,
GETSUMDEPT(DEPARTMENT_ID) SUMSALARY
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 100;

--PL/SQL 예외

DECLARE
VFIRST_NAME EMPLOYEES.FIRST_NAME%TYPE;
BEGIN
SELECT FIRST_NAME INTO VFIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE'0%';
DBMS_OUTPUT.PUT_LINE('사원명은' || VFIRST_NAME||'입니다');
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('해당사원이 존재하지 않습니다');
WHEN TOO_MANY_ROWS THEN
DBMS_OUTPUT.PUT_LINE('현재 단어를 포함한 사원이 두명 이상 존재합니다');
END;
/

DROP TABLE EMP04;
CREAT TABLE EMP04
AS
SELECT EMPLOYEE_ID, FIRST_NAME EMPLOYEES;

CREATE TABLE EMP01 AS
SELECT *FROM EMPLOYEES;

DROP TABLE EMP02;

CREATE OR REPLACE VIEW VIEW_EMP02
AS
SELECT EMPLOYEE_ID 사원번호, FIRST_NAME 사원명, SALARY 급여 , DEPARTMENT_ID 부서번호
FROM EMP01;

CREATE OR REPLACE VIEW VIEW_EMP02(사원번호, 사원명, 급여, 부서번호)
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY,DEPARTMENT_ID
FROM EMP01;
DESC VIEW_EMP02;

--RAISE 를 사용하여 예외 처리하기
--예제를 수행하기 위해서는 EMP04테이블을 삭제하고 (존재한다면 ) 다시 생성한다

DROP TABLE EMP04;
CREATE TABLE EMP04
AS
SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES;

SELECT EMPLOYEE_ID, FIRST_NAME FROM EMP04 ORDER BY EMPLOYEE_ID;

CREATE OR REPLACE PROCEDURE NOEMPNO_EXCEPTION
(VEMPLOYEE_ID EMP04.EMPLOYEE_ID%TYPE)
IS
EXEMPID EXCEPTION;
BEGIN
DELETE FROM EMP04 WHERE EMPLOYEE_ID = VEMPLOYEE_ID;
IF SQL%NOTFOUND THEN RAISE EXEMPID;
ELSE
DBMS_OUTPUT.PUT_LINE(CONCAT(VEMPLOYEE_ID,'사원이 삭제되었습니다'));
END IF;
EXCEPTION
WHEN EXEMPID THEN
DBMS_OUTPUT.PUT_LINE('입력하신 번호는 없는 사원번호입니다');
END;
/

EXEC NOEMPNO_EXCEPTION(800);
EXEC NOEMPNO_EXCEPTION(100);

--패키지 
--관련 있는 프로시저를 보다 효율적으로 관리하기 위해서 패키지 단위로 배폴할 때 유용하게 사용된다
--패키지는 연관성이 높은 함수나 프로시저를 하나의 그룹으로 묶어두는 개념
--패키지 선언부와 패키지 몸체부로 구성
--패키지 선언부의 역할은 해당 패키지에 사용될 함수나 프로시저, 변수등에 대한 정의를 선언한 부분 
--패키지 몸체부에서는 선언부에서 선언된 함수나 프로시저등이 실제 구현되는 부분임

CREATE OR REPLACE PACKAGE EMPPACK
IS
PROCEDURE EMPPROC;
PROCEDURE EMPPROC02( V


CREATE OR REPLACE PROCEDURE EMPPROC
IS 
VWORD VARCHAR2(1);
VEMPLOYEES EMPLOYEES%ROWTYPE;
CURSOR C1 (VWORD VARCHAR2)
IS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES WHERE FIRST_NAME LIKE '%'||VWORD||'%';
BEGIN
VWORD := DBMS_RANDOM.STRING('U',1);
DBMS_OUTPUT.PUT_LINE('임의의 문자 : '||VWORD);
OPEN C1(VWORD);
DBMS_OUTPUT.PUT_LINE('임의의 문자 : '|| VWORD);
DBMS_OUTPUT.PUT_LINE('---------------------');
LOOP
FETCH C1 INTO VEMPLOYEES.EMPLOYEE_ID,VEMPLOYEES.FIRST_NAME,VEMPLOYEES.SALARY;
IF C1%ROWCOUNT = 0 THEN
DBMS_OUTPUT.PUT_LINE('해당 사원이 존재하지 않습니다');
END IF;
EXIT WHEN C1%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(VEMPLOYEES.EMPLOYEE_ID||'/'||VEMPLOYEES.FIRST_NAME||'/'||
VEMPLOYEES.SALARY);
END LOOP;
END;
/


CREATE OR REPLACE PROCEDURE EMPPROC02(VDEPARTMENT_ID IN EMPLOYEES.DEPARTMENT_ID%TYPE)
IS 
CURSOR C1
IS 
SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
BEGIN
DBMS_OUTPUT.PUT_LINE('사원번호/사원명/급여');
DBMS_OUTPUT.PUT_LINE('-----------------');
FOR VEMPLOYEES IN C1 LOOP
DBMS_OUTPUT.PUT_LINE(VEMPLOYEES.EMPLOYEE_ID||'/'||VEMPLOYEES.FIRST_NAME||'/'||
VEMPLOYEES.SALARY);
END LOOP;
END;
/
