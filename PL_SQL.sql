DECLARE
--%ROWTYPE속성으로 로우를 저장할수있는 레퍼런스 변수선언
VEMPLOYEES EMPLOYEES%ROWTYPE;
VSALARY NUMBER(8,2);
BEGIN
DBMS_OUTPUT.PUT_LINE('사번/이름/급여');
DBMS_OUTPUT.PUT_LINE('-------------');
--Pat사원의 전체 정보를 로우 단위로 얻어와 vemployees에 저장한다
SELECT* INTO VEMPLOYEES
FROM EMPLOYEES
WHERE FIRST_NAME='Pat';
--커미션이 null일 경우 이를 0으로 변경해야 올바른 급여 계산이 가능하다
IF(VEMPLOYEES.COMMISSION_PCT IS NULL) THEN
VEMPLOYEES.COMMISSION_PCT := 0;
END IF;

--스칼라 변수에 급여를 계산할 결과를 저장한다
VSALARY := VEMPLOYEES.SALARY+(VEMPLOYEES.SALARY*VEMPLOYEES.COMMISSION_PCT);
--레퍼런스 변수와 스칼라 변수에 저장된 값을 출력한다
DBMS_OUTPUT.PUT_LINE('사원번호:'||VEMPLOYEES.EMPLOYEE_ID||
'/사원명:'||VEMPLOYEES.FIRST_NAME||
'/급여:'||TO_CHAR(VSALARY,'$999,999'));
END;
/

DECLARE
--%ROWTYPE 속성으로 로우를 저장할수있는 레퍼런스 변수 선언
VEMPLOYEES EMPLOYEES%ROWTYPE;
VDEPARTMENT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('사번/이름/부서번호/부서명');
DBMS_OUTPUT.PUT_LINE('----------------------');
--사원번호가 192 사원의 전체 정보를 로우단위로 얻어와 VEMPLOYEES에 저장한다
SELECT*INTO VEMPLOYEES FROM EMPLOYEES WHERE EMPLOYEE_ID=192;

IF(VEMPLOYEES.DEPARTMENT_ID=10)THEN
VDEPARTMENT_NAME:='ADMINISTRATION';
ELSIF(VEMPLOYEES.DEPARTMENT_ID=20)THEN
VDEPARTMENT_NAME:='MARKETING';
ELSIF(VEMPLOYEES.DEPARTMENT_ID=30)THEN
VDEPARTMENT_NAME:='PURCHASING';
ELSIF(VEMPLOYEES.DEPARTMENT_ID=40)THEN
VDEPARTMENT_NAME:='HUMANRESOURCES';
ELSIF(VEMPLOYEES.DEPARTMENT_ID=50)THEN
VDEPARTMENT_NAME:='SHIPPING';
END IF;
DBMS_OUTPUT.PUT_LINE(VEMPLOYEES.EMPLOYEE_ID||'/'||VEMPLOYEES.FIRST_NAME||'/'||
RPAD(VEMPLOYEES.DEPARTMENT_ID,4)||'/'||VDEPARTMENT_NAME);
END;
/

--DBMS_RANDOM.VALUE
--랜덤한 숫자를 생성한다
--형식 : DBMS_RANDOM.VALUE(최소 범위의 숫자, 최대 범위의 숫자)


--DBMS_RANDOM.STRING
--랜덤한 문자열을 생성한다
--형식 DBMS_RANDOM.STRING(옵션 문자, 길이 수)

SELECT DBMS_RANDOM.STRING('U',1)FROM DUAL;
SELECT DBMS_RANDOM.STRING('A',2)FROM DUAL;

DECLARE
VSALARY NUMBER :=0;
VDEPARTMENT_ID NUMBER :=0;
BEGIN
SELECT ROUND(DBMS_RANDOM.VALUE(10,270),-1)INTO VDEPARTMENT_ID FROM DUAL;

SELECT SALARY INTO VSALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = VDEPARTMENT_ID AND ROWNUM =1;
DBMS_OUTPUT.PUT_LINE('부서번호:'|| VDEPARTMENT_ID||'급여:'||VSALARY);

IF VSALARY BETWEEN 1 AND 6000 THEN
DBMS_OUTPUT.PUT_LINE('낮음');
ELSIF VSALARY BETWEEN 6001 AND 10000 THEN
DBMS_OUTPUT.PUT_LINE('중간');
ELSIF VSALARY BETWEEN 1001 AND 20000 THEN
DBMS_OUTPUT.PUT_LINE('높음');
ELSE
DBMS_OUTPUT.PUT_LINE('최상위');
END IF;
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE(VDEPARTMENT_ID||'부서에 해당 사원이 없습니다');
END;
/

--반복문 LOOP
DECLARE
VN_BASE_NUM NUMBER :=3;
VN_CNT NUMBER :=1;
BEGIN
DBMS_OUTPUT.PUT_LINE('*****구구단 3단 *****');
LOOP
DBMS_OUTPUT.PUT_LINE(VN_BASE_NUM||'*'||VN_CNT||'='||VN_BASE_NUM*VN_CNT);
VN_CNT:=VN_CNT+1;
--EXIT WHEN VN_CNT>9;
IF VN_CNT>9 THEN
EXIT;
END IF;
END LOOP;
END;
/

--FOR LOOP문 반복되는 횟수가 정해진 반복문 처리

DECLARE 
VDEPARTMENTS DEPARTMENTS%ROWTYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호/부서명/지역명');
DBMS_OUTPUT.PUT_LINE('-----------------------------');
--변수 CNT 는 1부터 1씩 증가하다가 27에 도달하면 반복문에서 벗아난다
FOR CNT IN 1..27 LOOP
SELECT*INTO VDEPARTMENTS FROM DEPARTMENTS
WHERE DEPARTMENT_ID = 10*CNT;
DBMS_OUTPUT.PUT_LINE(VDEPARTMENTS.DEPARTMENT_ID||'/'||
VDEPARTMENTS.DEPARTMENT_NAME||'/'||VDEPARTMENTS.LOCATION_ID);
END LOOP;
END;
/

--WHILE LOOP문
--제어조건이 TRUE인 동안만 일련의문장을 반복하기 위해 WHILE LOOP문장을 사용한다

DECLARE
I NUMBER :=1;
VDEPARTMENTS DEPARTMENTS%ROWTYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호/부서명/지역명');
DBMS_OUTPUT.PUT_LINE('----------------------------');
WHILE I <= 27 LOOP
IF I MOD 2 = 0 THEN
SELECT * INTO VDEPARTMENTS FROM DEPARTMENTS WHERE DEPARTMENT_ID = 10*I;
DBMS_OUTPUT.PUT_LINE(VDEPARTMENTS.DEPARTMENT_ID||'/'||
VDEPARTMENTS.DEPARTMENT_NAME||'/'||VDEPARTMENTS.LOCATION_ID);
END IF;
I := I+1;
END LOOP;
END;
/

--커서란 특정 SQL문장을 처리한 결과를담고있는영역을가리키는 일종의 포인터로 ,
--SQL문장의 결과 집합에 접근할수있다

--%NOTFOUND 커서영역의 자료가 모두 FETCH되었다면 TRUE
--%FOUND 커서영역에 FETCH되지 않은 자료가 있다면 TRUE
--%ISOPEN 커서가 OPEN된 상태이면 TRUE
--%ROWCOUNT 커서가 얻어온 레코드의 개수

DECLARE
VDEPARTMENTS DEPARTMENTS%ROWTYPE;
CURSOR C1 --커서의 이름
IS
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM DEPARTMENTS;
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호/부서명/지역명');
DBMS_OUTPUT.PUT_LINE('------------------------');

OPEN C1;
--오픈한 C1커서가 SELECT 문에 의해 검색된 한개의 행의 정보를 읽어온다
LOOP--읽어온 정보는 INTO두에 기술한 변수에저장
FETCH C1 INTO VDEPARTMENTS.DEPARTMENT_ID, VDEPARTMENTS.DEPARTMENT_NAME,
VDEPARTMENTS.LOCATION_ID;
EXIT WHEN C1 %NOTFOUND;
DBMS_OUTPUT.PUT_LINE(VDEPARTMENTS.DEPARTMENT_ID||''||
RPAD(VDEPARTMENTS.DEPARTMENT_NAME, 20)||''||VDEPARTMENTS.LOCATION_ID);
END LOOP;
CLOSE C1;
END;
/

--CURSOR와 FOR LOOP(묵시적으로 CURSOR에서 행을 처리한다)
--LOOP에서 각 반복마다 CURSOR을 열고 행을 인출 하고 모든 행이 처리되면 자동으로 CURSOR가 
--CLOSE되므로 사용하기가 편리하다

DECLARE
VDEPARTMENTS DEPARTMENTS%ROWTYPE;
CURSOR C1 -- 커서의 이름
IS 
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM DEPARTMENTS;
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호/부서명/지역명');
DBMS_OUTPUT.PUT_LINE('-------------------');

OPEN C1;
--오픈한 C1 커서가 SELECT 문에 의해 검색된 하개의 행의 정보를 읽어온다
LOOP--읽어온 정보는 INTO 뒤에 기술한 변수에 저장
FETCH C1 INTO VDEPARTMENTS.DEPARTMENT_ID, VDEPARTMENTS.DEPARTMENT_NAME,
VDEPARTMENTS.LOCATION_ID;
EXIT WHEN C1 %NOTFOUND;
DBMS_OUTPUT.PUT_LINE(VDEPARTMENTS.DEPARTMENT_ID||''||
RPAD(VDEPARTMENTS.DEPARTMENT_NAME,20)||''||VDEPARTMENTS.LOCATION_ID);
END LOOP;
CLOSE C1;
END;
/

--CURSOR와 FOR LOOP(묵시적으로 CURSOR에서 행을 처리한다)
--LOOP에서 각 반복마다 CURSOR를 열고 행을 인출하고 모든 행이 처리되면 
--자동으로 CURSOR가 CLOSE되므로 사용하기가 편리하다

DECLARE
VDEPARTMENTS DEPARTMENTS%ROWTYPE;
CURSOR C1
IS
SELECT * FROM DEPARTMENTS;
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호/부서번호/지역명');
DBMS_OUTPUT.PUT_LINE('-----------------------');
FOR VDEPARTMENTS IN C1 LOOP
DBMS_OUTPUT.PUT_LINE(VDEPARTMENTS.DEPARTMENT_ID||''||
RPAD(VDEPARTMENTS.DEPARTMENT_NAME,20) ||''||VDEPARTMENTS.LOCATION_ID);
END LOOP;
END;
/

DECLARE
VDEPARTMENTS DEPARTMENTS%ROWTYPE;
BEGIN
DBMS_OUTPUT.PUT_LINE('부서번호/부서명/지역명');
DBMS_OUTPUT.PUT_LINE('-------------------');
FOR VDEPARTMENTS IN (SELECT * FROM DEPARTMENTS ) LOOP -- 커서정의 부분을 FOR문에서 직접명시
DBMS_OUTPUT.PUT_LINE(VDEPARTMENTS.DEPARTMENT_ID||''||
RPAD(VDEPARTMENTS.DEPARTMENT_NAME,20)||''||VDEPARTMENTS.LOCATION_ID);
END LOOP;
END;
/



DECLARE
VRANDOMID EMPLOYEES.DEPARTMENT_ID%TYPE;--임의의 부서번호
VSALARYSTRING VARCHAR2(20);
--커서 선언시 매개변수를 명시할수 있다 CURSOR커서명 (매개변수)IS 쿼리문
CURSOR CUR_EMPLOYEES(VDEPARTMENT_ID EMPLOYEES.DEPARTMENT_ID%TYPE)
IS
SELECT SALARY, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
BEGIN
--임의의 부서번호를 얻어 출력
SELECT ROUND(DBMS_RANDOM.VALUE(10,270),-1) INTO VRANDOMID FROM DUAL;
DBMS_OUTPUT.PUT_LINE('부서번호:'||VRANDOMID);

--그 부서번호가 120에서 270번까지 소속된 사원이 없기에 제어
IF VRANDOMID BETWEEN 120 AND 270 THEN
DBMS_OUTPUT.PUT_LINE(VRANDOMID||'부서에 해당 사원이 없습니다');
RETURN;--블록을 종료
END IF;

DBMS_OUTPUT.PUT_LINE('사원명/급여/급여수준');
DBMS_OUTPUT.PUT_LINE('----------------');

FOR VEMPLOYEES IN CUR_EMPLOYEES(VRANDOMID)LOOP
IF VEMPLOYEES.SALARY BETWEEN 1 AND 6000 THEN
VSALARYSTRING:='낮음';
ELSIF VEMPLOYEES.SALARY BETWEEN 6001 AND 10000 THEN
VSALARYSTRING:='중간';
ELSIF VEMPLOYEES.SALARY BETWEEN 10001 AND 20000 THEN
VSALARYSTRING:='높음';
ELSE
VSALARYSTRING:='최상위';
END IF;
DBMS_OUTPUT.PUT_LINE(RPAD(VEMPLOYEES.FIRST_NAME,6)||'/'||RPAD(VEMPLOYEES.SALARY,5)||'/'||VSALARYSTRING);
END LOOP;
END;
/


--커서 변수 선언
--오라클에서 제공하는 커서 타입 인 SYS_REFCURSOR이란 타입을 사용하는 것이다
--따라서 SYS_REFCURSOR를 사용할때는 별도로 커서 타입을 선언할 필요없이 
--다음과 같이 커서변수만 선언하면 된다
-- 커서변수 SYSREFCURSOR;
DECLARE
VFIRST_NAME EMPLOYEES.FIRST_NAME%TYPE;
TYPE EMPLOYEESCURSOR IS REF CURSOR;--커서 타입 선언
VEMPLOYEES EMPLOYEESCURSOR;--커서 변수선언
BEGIN
--커서변수를 사용한 커서 정의 및 오픈
OPEN VEMPLOYEES FOR SELECT FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 60;

LOOP
--커서변수를 사용해 결과 집합을 EMPNAME 변수에 할당
FETCH VEMPLOYEES INTO VFIRST_NAME;
EXIT WHEN VEMPLOYEES%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('사원명:'||VFIRST_NAME);--사원명을 출력
END LOOP;
END;
/